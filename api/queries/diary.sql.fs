// Code generated by sqlc. DO NOT EDIT.
// source: diary.sql


module Diary 

open Npgsql
open Npgsql.FSharp
open System




let addNote = """-- name: AddNote :one
INSERT INTO diary (note_id, user_id, note, last_updated) VALUES (@note_id, @user_id, @note, now())  
ON CONFLICT (note_id, user_id) DO UPDATE SET note = EXCLUDED.note, last_updated =  EXCLUDED.last_updated
returning id, user_id, note_id, note, last_updated
"""


type AddNoteParams = {
  NoteId: string;
  UserId: int32;
  Note: string;
}

let AddNote (db: NpgsqlConnection)  (arg: AddNoteParams)  =
  
  let reader = fun (read:RowReader) -> {
    Id = read.int "id"
    UserId = read.int "user_id"
    NoteId = read.string "note_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  

  db
  |> Sql.existingConnection
  |> Sql.query addNote
  |> Sql.parameters  [ "@note_id", Sql.string arg.NoteId; "@user_id", Sql.int arg.UserId; "@note", Sql.string arg.Note ]
  |> Sql.executeRow reader












let checkIdStale = """-- name: CheckIdStale :one
SELECT count(*)  > 0 as stale
FROM diary d
LEFT JOIN summary s ON d.id = s.id AND d.user_id = s.user_id AND d.user_id = @user_id AND d.note_id = @note_id
WHERE s.id IS NULL OR d.last_updated > s.last_updated
"""


type CheckIdStaleParams = {
  UserId: int32;
  NoteId: string;
}

let CheckIdStale (db: NpgsqlConnection)  (arg: CheckIdStaleParams)  =
  
  let reader = fun (read:RowReader) -> read.bool "stale"

  db
  |> Sql.existingConnection
  |> Sql.query checkIdStale
  |> Sql.parameters  [ "@user_id", Sql.int arg.UserId; "@note_id", Sql.string arg.NoteId ]
  |> Sql.executeRow reader














let createDiary = """-- name: CreateDiary :one
INSERT INTO diary (id, note) VALUES (@id, @note)
RETURNING id, user_id, note_id, note, last_updated
"""


type CreateDiaryParams = {
  Id: int32;
  Note: string;
}

let CreateDiary (db: NpgsqlConnection)  (arg: CreateDiaryParams)  =
  
  let reader = fun (read:RowReader) -> {
    Id = read.int "id"
    UserId = read.int "user_id"
    NoteId = read.string "note_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  

  db
  |> Sql.existingConnection
  |> Sql.query createDiary
  |> Sql.parameters  [ "@id", Sql.int arg.Id; "@note", Sql.string arg.Note ]
  |> Sql.executeRow reader















let deleteDiary = """-- name: DeleteDiary :exec
DELETE FROM diary WHERE id = @id
"""






let DeleteDiary (db: NpgsqlConnection)  (id: int32)  = 
  db 
  |> Sql.existingConnection
  |> Sql.query deleteDiary
  |> Sql.parameters  [ "@id", Sql.int id ]
  |> Sql.executeNonQuery








let diaryByID = """-- name: DiaryByID :one
SELECT id, user_id, note_id, note, last_updated FROM diary WHERE id = @id
"""



let DiaryByID (db: NpgsqlConnection)  (id: int32)  =
  
  let reader = fun (read:RowReader) -> {
    Id = read.int "id"
    UserId = read.int "user_id"
    NoteId = read.string "note_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  

  db
  |> Sql.existingConnection
  |> Sql.query diaryByID
  |> Sql.parameters  [ "@id", Sql.int id ]
  |> Sql.executeRow reader












let diaryByUserIDAndID = """-- name: DiaryByUserIDAndID :one
SELECT id, user_id, note_id, note, last_updated FROM diary WHERE user_id = @user_id and note_id=@note_id
"""


type DiaryByUserIDAndIDParams = {
  UserId: int32;
  NoteId: string;
}

let DiaryByUserIDAndID (db: NpgsqlConnection)  (arg: DiaryByUserIDAndIDParams)  =
  
  let reader = fun (read:RowReader) -> {
    Id = read.int "id"
    UserId = read.int "user_id"
    NoteId = read.string "note_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  

  db
  |> Sql.existingConnection
  |> Sql.query diaryByUserIDAndID
  |> Sql.parameters  [ "@user_id", Sql.int arg.UserId; "@note_id", Sql.string arg.NoteId ]
  |> Sql.executeRow reader
















let getStaleIdsOfUserId = """-- name: GetStaleIdsOfUserId :many
SELECT d.id, d.user_id, d.note_id, d.note, d.last_updated
FROM diary d
LEFT JOIN summary s ON d.id = s.id AND d.user_id = s.user_id 
WHERE (s.id IS NULL OR d.last_updated > s.last_updated) AND d.user_id = @user_id
"""




let GetStaleIdsOfUserId (db: NpgsqlConnection)  (userId: int32) =
  let reader = fun (read:RowReader) -> {
    Id = read.int "id"
    UserId = read.int "user_id"
    NoteId = read.string "note_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  
  db 
  |> Sql.existingConnection
  |> Sql.query getStaleIdsOfUserId
  |> Sql.parameters  [ "@user_id", Sql.int userId ]
  |> Sql.execute reader

















let listDiaries = """-- name: ListDiaries :many
SELECT id, user_id, note_id, note, last_updated FROM diary ORDER BY last_updated DESC
"""




let ListDiaries (db: NpgsqlConnection)  =
  let reader = fun (read:RowReader) -> {
    Id = read.int "id"
    UserId = read.int "user_id"
    NoteId = read.string "note_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  
  db 
  |> Sql.existingConnection
  |> Sql.query listDiaries
  |> Sql.execute reader










let listDiaryByUserID = """-- name: ListDiaryByUserID :many
SELECT id, user_id, note_id, note, last_updated FROM diary WHERE user_id = @user_id order by note_id DESC
"""




let ListDiaryByUserID (db: NpgsqlConnection)  (userId: int32) =
  let reader = fun (read:RowReader) -> {
    Id = read.int "id"
    UserId = read.int "user_id"
    NoteId = read.string "note_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  
  db 
  |> Sql.existingConnection
  |> Sql.query listDiaryByUserID
  |> Sql.parameters  [ "@user_id", Sql.int userId ]
  |> Sql.execute reader










let listDiaryIDByUserID = """-- name: ListDiaryIDByUserID :many
SELECT note_id FROM diary WHERE user_id = @user_id order by note_id DESC
"""




let ListDiaryIDByUserID (db: NpgsqlConnection)  (userId: int32) =
  let reader = fun (read:RowReader) -> read.string "note_id"
  
  db 
  |> Sql.existingConnection
  |> Sql.query listDiaryIDByUserID
  |> Sql.parameters  [ "@user_id", Sql.int userId ]
  |> Sql.execute reader












let updateDiary = """-- name: UpdateDiary :one
UPDATE diary SET note = @note, last_updated = NOW() WHERE id = @id
RETURNING id, user_id, note_id, note, last_updated
"""


type UpdateDiaryParams = {
  Id: int32;
  Note: string;
}

let UpdateDiary (db: NpgsqlConnection)  (arg: UpdateDiaryParams)  =
  
  let reader = fun (read:RowReader) -> {
    Id = read.int "id"
    UserId = read.int "user_id"
    NoteId = read.string "note_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  

  db
  |> Sql.existingConnection
  |> Sql.query updateDiary
  |> Sql.parameters  [ "@id", Sql.int arg.Id; "@note", Sql.string arg.Note ]
  |> Sql.executeRow reader














