// Code generated by sqlc. DO NOT EDIT.
// source: diary.sql


module Diary 

open Npgsql
open Npgsql.FSharp
open System




let addNote = """-- name: AddNote :exec
INSERT INTO diary (id, user_id, note, last_updated) VALUES (@id, @user_id, @note, now())  
ON CONFLICT (id) DO UPDATE SET note = EXCLUDED.note, last_updated =  EXCLUDED.last_updated
"""


type AddNoteParams = {
  Id: string;
  UserId: int32;
  Note: string;
}




let AddNote (db: NpgsqlConnection)  (arg: AddNoteParams)  = 
  db 
  |> Sql.existingConnection
  |> Sql.query addNote
  |> Sql.parameters  [ "@id", Sql.string arg.Id; "@user_id", Sql.int arg.UserId; "@note", Sql.string arg.Note ]
  |> Sql.executeNonQuery









let createDiary = """-- name: CreateDiary :one
INSERT INTO diary (id, note) VALUES (@id, @note)
RETURNING id, user_id, note, last_updated
"""


type CreateDiaryParams = {
  Id: string;
  Note: string;
}

let CreateDiary (db: NpgsqlConnection)  (arg: CreateDiaryParams)  =
  
  let reader = fun (read:RowReader) -> {
    Id = read.string "id"
    UserId = read.int "user_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  

  db
  |> Sql.existingConnection
  |> Sql.query createDiary
  |> Sql.parameters  [ "@id", Sql.string arg.Id; "@note", Sql.string arg.Note ]
  |> Sql.executeRow reader















let deleteDiary = """-- name: DeleteDiary :exec
DELETE FROM diary WHERE id = @id
"""






let DeleteDiary (db: NpgsqlConnection)  (id: string)  = 
  db 
  |> Sql.existingConnection
  |> Sql.query deleteDiary
  |> Sql.parameters  [ "@id", Sql.string id ]
  |> Sql.executeNonQuery








let diaryByID = """-- name: DiaryByID :one
SELECT id, user_id, note, last_updated FROM diary WHERE id = @id
"""



let DiaryByID (db: NpgsqlConnection)  (id: string)  =
  
  let reader = fun (read:RowReader) -> {
    Id = read.string "id"
    UserId = read.int "user_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  

  db
  |> Sql.existingConnection
  |> Sql.query diaryByID
  |> Sql.parameters  [ "@id", Sql.string id ]
  |> Sql.executeRow reader












let diaryByUserIDAndID = """-- name: DiaryByUserIDAndID :one
SELECT id, user_id, note, last_updated FROM diary WHERE user_id = @user_id and id=@id
"""


type DiaryByUserIDAndIDParams = {
  UserId: int32;
  Id: string;
}

let DiaryByUserIDAndID (db: NpgsqlConnection)  (arg: DiaryByUserIDAndIDParams)  =
  
  let reader = fun (read:RowReader) -> {
    Id = read.string "id"
    UserId = read.int "user_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  

  db
  |> Sql.existingConnection
  |> Sql.query diaryByUserIDAndID
  |> Sql.parameters  [ "@user_id", Sql.int arg.UserId; "@id", Sql.string arg.Id ]
  |> Sql.executeRow reader
















let getStaleIdsOfUserId = """-- name: GetStaleIdsOfUserId :many
SELECT d.id, d.user_id, d.note, d.last_updated
FROM diary d
LEFT JOIN summary s ON d.id = s.id AND d.user_id = s.user_id AND d.user_id = @user_id
WHERE s.id IS NULL OR d.last_updated > s.last_updated
"""




let GetStaleIdsOfUserId (db: NpgsqlConnection)  (userId: int32) =
  let reader = fun (read:RowReader) -> {
    Id = read.string "id"
    UserId = read.int "user_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  db 
  |> Sql.existingConnection
  |> Sql.query getStaleIdsOfUserId
  |> Sql.parameters  [ "@user_id", Sql.int userId ]
  |> Sql.execute reader

















let listDiaries = """-- name: ListDiaries :many
SELECT id, user_id, note, last_updated FROM diary ORDER BY last_updated DESC
"""




let ListDiaries (db: NpgsqlConnection)  =
  let reader = fun (read:RowReader) -> {
    Id = read.string "id"
    UserId = read.int "user_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  db 
  |> Sql.existingConnection
  |> Sql.query listDiaries
  |> Sql.execute reader










let listDiaryByUserID = """-- name: ListDiaryByUserID :many
SELECT id, user_id, note, last_updated FROM diary WHERE user_id = @user_id
"""




let ListDiaryByUserID (db: NpgsqlConnection)  (userId: int32) =
  let reader = fun (read:RowReader) -> {
    Id = read.string "id"
    UserId = read.int "user_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  db 
  |> Sql.existingConnection
  |> Sql.query listDiaryByUserID
  |> Sql.parameters  [ "@user_id", Sql.int userId ]
  |> Sql.execute reader












let updateDiary = """-- name: UpdateDiary :one
UPDATE diary SET note = @note, last_updated = NOW() WHERE id = @id
RETURNING id, user_id, note, last_updated
"""


type UpdateDiaryParams = {
  Id: string;
  Note: string;
}

let UpdateDiary (db: NpgsqlConnection)  (arg: UpdateDiaryParams)  =
  
  let reader = fun (read:RowReader) -> {
    Id = read.string "id"
    UserId = read.int "user_id"
    Note = read.string "note"
    LastUpdated = read.dateTime "last_updated"}
  

  db
  |> Sql.existingConnection
  |> Sql.query updateDiary
  |> Sql.parameters  [ "@id", Sql.string arg.Id; "@note", Sql.string arg.Note ]
  |> Sql.executeRow reader














